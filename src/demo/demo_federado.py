# ./src/demo/demo_federado.py

from src.api.storage import AlmacenResultados
from src.api.federado import ProcesadorFederado
from src.cliente.cliente_federado import ClienteFederado
import sys
import os
import time
import asyncio
import pandas as pd
import json
from datetime import datetime
from typing import List, Dict

# Agregar el directorio ra√≠z al path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))


class DemostracionFederada:
    """
    Demostraci√≥n completa del sistema de aprendizaje federado.

    Simula m√∫ltiples empresas del cl√∫ster tur√≠stico:
    1. Cada empresa entrena modelos localmente
    2. Env√≠an par√°metros anonimizados al sistema federado
    3. El sistema agrega los modelos sin revelar datos individuales
    4. Las empresas pueden consultar modelos agregados
    5. Se generan predicciones y m√©tricas del cl√∫ster
    """

    def __init__(self, num_empresas: int = 5):
        """
        Inicializar la demostraci√≥n.

        Parameters
        ----------
        num_empresas : int
            N√∫mero de empresas a simular
        """
        self.num_empresas = num_empresas
        self.empresas_participantes = []
        self.clientes_federados = []
        self.procesador = ProcesadorFederado()
        self.almacen = AlmacenResultados()

        print("üé≠ DEMOSTRACI√ìN DEL SISTEMA FEDERADO")
        print("=" * 60)
        print(f"Simulando {num_empresas} empresas del Cl√∫ster de Turismo de Nuevo Le√≥n")
        print("üîí Garantizando privacidad completa en todo el proceso")

    def cargar_empresas_demo(self):
        """
        Cargar empresas para la demostraci√≥n.
        """
        try:
            empresas_df = pd.read_csv('data/datos_sinteticos/empresas_dummy.csv')

            # Seleccionar empresas de diferentes giros
            giros_diversos = empresas_df['giro'].unique()[:self.num_empresas]

            for giro in giros_diversos:
                empresa = empresas_df[empresas_df['giro'] == giro].iloc[0]
                self.empresas_participantes.append({
                    'empresa_id': empresa['empresa_id'],
                    'giro': empresa['giro'],
                    'capacidad_base': empresa['capacidad_base'],
                    'precio_promedio_base': empresa['precio_promedio_base']
                })

            print(f"\nüè¢ Empresas participantes cargadas:")
            for i, empresa in enumerate(self.empresas_participantes, 1):
                print(f"  {i}. Giro: {empresa['giro']}")

            return True

        except FileNotFoundError:
            print("‚ùå Error: No se encontraron datos sint√©ticos")
            print("   Ejecuta primero: python src/datos_sinteticos/generar_todos_datos.py")
            return False

    def crear_clientes_federados(self):
        """
        Crear clientes federados para cada empresa.
        """
        print(f"\nü§ñ Creando clientes federados...")

        for empresa in self.empresas_participantes:
            cliente = ClienteFederado(
                empresa_id=empresa['empresa_id'],
                giro=empresa['giro'],
                api_url="http://localhost:8000"  # En demo, no hay API real
            )
            self.clientes_federados.append(cliente)

        print(f"‚úÖ {len(self.clientes_federados)} clientes federados creados")

    def fase_entrenamiento_local(self):
        """
        Fase 1: Cada empresa entrena modelos localmente.
        """
        print(f"\n" + "=" * 60)
        print("üìö FASE 1: ENTRENAMIENTO LOCAL")
        print("=" * 60)
        print("Cada empresa entrena modelos con sus datos locales")
        print("üîí Los datos NUNCA salen de cada empresa")

        modelos_entrenados = []
        metricas_generadas = []

        for i, cliente in enumerate(self.clientes_federados, 1):
            print(f"\nüè¢ Empresa {i}/{len(self.clientes_federados)} - Giro: {cliente.giro}")
            print("-" * 40)

            # Cargar datos locales
            if not cliente.cargar_datos_locales():
                print(f"‚ö†Ô∏è Empresa {i} no tiene datos suficientes, saltando...")
                continue

            try:
                # Entrenar modelos
                modelo_prediccion = cliente.entrenar_modelo_prediccion_demanda()
                modelo_clasificacion = cliente.entrenar_modelo_clasificacion_viajero()

                # Generar m√©tricas agregadas
                metricas = cliente.generar_metricas_agregadas()

                modelos_entrenados.append({
                    'cliente': cliente,
                    'prediccion': modelo_prediccion,
                    'clasificacion': modelo_clasificacion
                })

                metricas_generadas.append(metricas)

                print(f"‚úÖ Empresa {i} complet√≥ entrenamiento local")

            except Exception as e:
                print(f"‚ùå Error en empresa {i}: {e}")
                continue

        print(f"\nüìä RESUMEN FASE 1:")
        print(f"  Empresas con modelos entrenados: {len(modelos_entrenados)}")
        print(f"  Empresas con m√©tricas generadas: {len(metricas_generadas)}")

        return modelos_entrenados, metricas_generadas

    async def fase_agregacion_federada(self, modelos_entrenados: List[Dict], metricas_generadas: List[Dict]):
        """
        Fase 2: Agregaci√≥n federada de modelos y m√©tricas.

        Parameters
        ----------
        modelos_entrenados : List[Dict]
            Lista de modelos entrenados por cada empresa
        metricas_generadas : List[Dict]
            Lista de m√©tricas generadas por cada empresa
        """
        print(f"\n" + "=" * 60)
        print("üîÑ FASE 2: AGREGACI√ìN FEDERADA")
        print("=" * 60)
        print("El sistema agrega modelos sin acceder a datos crudos")
        print("üîí Solo se procesan par√°metros completamente anonimizados")

        # Simular env√≠o de modelos al procesador federado
        contribuciones_prediccion = []
        contribuciones_clasificacion = []

        for i, modelo_data in enumerate(modelos_entrenados, 1):
            cliente = modelo_data['cliente']

            print(f"\nüì§ Procesando contribuciones de empresa {i}...")

            # Procesar modelo de predicci√≥n
            if modelo_data['prediccion']:
                contribucion_id = f"contrib_pred_{i}_{int(time.time())}"
                await self.procesador.procesar_modelo_anonimo(
                    type('ModeloFederado', (), modelo_data['prediccion'])(),
                    contribucion_id
                )
                contribuciones_prediccion.append(contribucion_id)
                print(f"  ‚úÖ Modelo de predicci√≥n procesado: {contribucion_id[:12]}...")

            # Procesar modelo de clasificaci√≥n
            if modelo_data['clasificacion']:
                contribucion_id = f"contrib_clf_{i}_{int(time.time())}"
                await self.procesador.procesar_modelo_anonimo(
                    type('ModeloFederado', (), modelo_data['clasificacion'])(),
                    contribucion_id
                )
                contribuciones_clasificacion.append(contribucion_id)
                print(f"  ‚úÖ Modelo de clasificaci√≥n procesado: {contribucion_id[:12]}...")

        # Procesar m√©tricas agregadas
        for i, metricas in enumerate(metricas_generadas, 1):
            resultado = await self.procesador.procesar_metricas_anonimas(
                type('MetricasEmpresa', (), metricas)()
            )
            print(f"  ‚úÖ M√©tricas empresa {i} procesadas: {resultado['id'][:12]}...")

        print(f"\nüìä RESUMEN FASE 2:")
        print(f"  Contribuciones predicci√≥n: {len(contribuciones_prediccion)}")
        print(f"  Contribuciones clasificaci√≥n: {len(contribuciones_clasificacion)}")
        print(f"  M√©tricas procesadas: {len(metricas_generadas)}")

        return contribuciones_prediccion, contribuciones_clasificacion

    async def fase_consulta_resultados(self):
        """
        Fase 3: Consulta de resultados agregados.
        """
        print(f"\n" + "=" * 60)
        print("üìä FASE 3: CONSULTA DE RESULTADOS AGREGADOS")
        print("=" * 60)
        print("Las empresas consultan modelos y m√©tricas agregadas del cl√∫ster")
        print("üîí Solo reciben informaci√≥n agregada, nunca datos individuales")

        # Obtener m√©tricas generales del cl√∫ster
        print(f"\nüìà Consultando m√©tricas generales del cl√∫ster...")
        metricas_generales = await self.almacen.obtener_metricas_generales()

        print(f"‚úÖ M√©tricas generales obtenidas:")
        if 'metricas_economicas' in metricas_generales:
            economicas = metricas_generales['metricas_economicas']
            print(f"  üí∞ Ingresos totales cl√∫ster: ${economicas.get('ingresos_totales_cluster', 0):,.0f}")
            print(f"  üë• Clientes totales atendidos: {economicas.get('clientes_totales_atendidos', 0):,}")
            print(f"  üé´ Ticket promedio cl√∫ster: ${economicas.get('ticket_promedio_cluster', 0):,.0f}")

        # Consultar m√©tricas por giro
        print(f"\nüè¢ Consultando m√©tricas por giro...")
        giros_unicos = list(set([emp['giro'] for emp in self.empresas_participantes]))

        for giro in giros_unicos:
            metricas_giro = await self.almacen.obtener_metricas_por_giro(giro)
            if metricas_giro:
                print(f"  üìä {giro.capitalize()}:")
                economicas = metricas_giro.get('metricas_economicas', {})
                print(f"    Ingresos totales: ${economicas.get('ingresos_totales', 0):,.0f}")
                print(f"    Clientes promedio diario: {economicas.get('clientes_promedio_diario', 0):.0f}")

        # Generar predicciones de demanda
        print(f"\nüîÆ Generando predicciones de demanda...")
        for giro in giros_unicos[:2]:  # Solo primeros 2 giros para demo
            try:
                predicciones = await self.procesador.generar_predicciones_demanda(
                    giro=giro,
                    fecha_inicio="2025-06-01",
                    fecha_fin="2025-06-07"
                )

                print(f"  üéØ Predicciones para {giro}:")
                if predicciones and 'predicciones' in predicciones:
                    for pred in predicciones['predicciones'][:3]:  # Primeros 3 d√≠as
                        print(f"    {pred['fecha']}: {pred['prediccion']:.0f} (confianza: {pred['confianza']:.2f})")

            except Exception as e:
                print(f"  ‚ö†Ô∏è No se pudieron generar predicciones para {giro}: {e}")

        return metricas_generales

    async def fase_exportacion_resultados(self):
        """
        Fase 4: Exportaci√≥n de resultados para an√°lisis externo.
        """
        print(f"\n" + "=" * 60)
        print("üìÅ FASE 4: EXPORTACI√ìN DE RESULTADOS")
        print("=" * 60)
        print("Exportando resultados agregados para an√°lisis externo")
        print("üîí Solo datos completamente anonimizados")

        # Exportar en formato JSON
        archivo_json = await self.almacen.exportar_resultados_anonimos("json")
        print(f"‚úÖ Resultados exportados en JSON: {archivo_json}")

        # Exportar en formato CSV
        archivo_csv = await self.almacen.exportar_resultados_anonimos("csv")
        print(f"‚úÖ Resultados exportados en CSV: {archivo_csv}")

        # Obtener estad√≠sticas del sistema
        stats = await self.almacen.obtener_estadisticas_sistema()
        print(f"\nüìä Estad√≠sticas del sistema federado:")
        sistema = stats.get('sistema', {})
        print(f"  Total contribuciones: {sistema.get('total_contribuciones', 0)}")
        print(f"  Modelos agregados: {sistema.get('modelos_agregados', 0)}")
        print(f"  Predicciones generadas: {sistema.get('predicciones_generadas', 0)}")

        return archivo_json, archivo_csv

    def generar_reporte_final(self, metricas_generales: Dict, archivos_exportados: tuple):
        """
        Generar reporte final de la demostraci√≥n.

        Parameters
        ----------
        metricas_generales : Dict
            M√©tricas generales del cl√∫ster
        archivos_exportados : tuple
            Archivos exportados (JSON, CSV)
        """
        print(f"\n" + "=" * 60)
        print("üìã REPORTE FINAL DE LA DEMOSTRACI√ìN")
        print("=" * 60)

        reporte = {
            "timestamp_demo": datetime.now().isoformat(),
            "empresas_participantes": len(self.empresas_participantes),
            "giros_representados": list(set([emp['giro'] for emp in self.empresas_participantes])),
            "privacidad_garantizada": True,
            "datos_anonimizados": True,
            "modelos_agregados_exitosamente": True,
            "metricas_cluster_generadas": True,
            "archivos_exportados": {
                "json": archivos_exportados[0],
                "csv": archivos_exportados[1]
            },
            "resumen_economico": metricas_generales.get('metricas_economicas', {}),
            "nivel_agregacion": "cluster_completo",
            "empresas_individuales_no_identificables": True
        }

        # Guardar reporte
        ruta_reporte = "data/resultados/reporte_demo_federado.json"
        with open(ruta_reporte, 'w') as f:
            json.dump(reporte, f, indent=2)

        print(f"‚úÖ Demostraci√≥n completada exitosamente")
        print(f"üìä Empresas participantes: {len(self.empresas_participantes)}")
        print(f"üîí Privacidad garantizada: ‚úÖ")
        print(f"üìÅ Reporte guardado en: {ruta_reporte}")

        print(f"\nüéØ LOGROS DE LA DEMOSTRACI√ìN:")
        print(f"  ‚úÖ Entrenamiento local sin compartir datos crudos")
        print(f"  ‚úÖ Agregaci√≥n federada preservando privacidad")
        print(f"  ‚úÖ M√©tricas del cl√∫ster sin revelar empresas individuales")
        print(f"  ‚úÖ Predicciones basadas en conocimiento agregado")
        print(f"  ‚úÖ Exportaci√≥n de resultados anonimizados")

        print(f"\nüîê GARANT√çAS DE PRIVACIDAD:")
        print(f"  üõ°Ô∏è IDs de empresa completamente anonimizados")
        print(f"  üõ°Ô∏è Datos crudos nunca salen de cada empresa")
        print(f"  üõ°Ô∏è Solo par√°metros agregados se comparten")
        print(f"  üõ°Ô∏è Imposible rastrear contribuciones individuales")
        print(f"  üõ°Ô∏è Ruido diferencial aplicado para mayor seguridad")

        return reporte

    async def ejecutar_demo_completa(self):
        """
        Ejecutar la demostraci√≥n completa del sistema federado.
        """
        inicio_demo = time.time()

        print(f"üöÄ Iniciando demostraci√≥n completa...")
        print(f"‚è∞ Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        # Preparaci√≥n
        if not self.cargar_empresas_demo():
            return False

        self.crear_clientes_federados()

        # Fase 1: Entrenamiento local
        modelos_entrenados, metricas_generadas = self.fase_entrenamiento_local()

        if not modelos_entrenados:
            print("‚ùå No se pudieron entrenar modelos. Terminando demostraci√≥n.")
            return False

        # Fase 2: Agregaci√≥n federada
        contribuciones_pred, contribuciones_clf = await self.fase_agregacion_federada(
            modelos_entrenados, metricas_generadas
        )

        # Fase 3: Consulta de resultados
        metricas_generales = await self.fase_consulta_resultados()

        # Fase 4: Exportaci√≥n
        archivos_exportados = await self.fase_exportacion_resultados()

        # Reporte final
        reporte = self.generar_reporte_final(metricas_generales, archivos_exportados)

        tiempo_total = time.time() - inicio_demo
        print(f"\n‚è±Ô∏è Tiempo total de demostraci√≥n: {tiempo_total:.2f} segundos")

        return True


async def main():
    """
    Funci√≥n principal para ejecutar la demostraci√≥n.
    """
    print("üé≠ SISTEMA DE APRENDIZAJE FEDERADO")
    print("üèõÔ∏è Cl√∫ster de Turismo de Nuevo Le√≥n")
    print("üîí Demostraci√≥n de Privacidad Garantizada")
    print("=" * 60)

    # Crear y ejecutar demostraci√≥n
    demo = DemostracionFederada(num_empresas=5)

    try:
        exito = await demo.ejecutar_demo_completa()

        if exito:
            print(f"\nüéâ ¬°DEMOSTRACI√ìN COMPLETADA EXITOSAMENTE!")
            print(f"üîç Revisa los archivos en data/resultados/ para ver los resultados")
        else:
            print(f"\nüí• La demostraci√≥n no se pudo completar")

    except Exception as e:
        print(f"\n‚ùå Error durante la demostraci√≥n: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    # Ejecutar demostraci√≥n
    asyncio.run(main())
